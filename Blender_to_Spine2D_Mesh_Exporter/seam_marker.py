# seam_marker.py
# pylint: disable=import-error
"""
Blender to Spine2D Mesh Exporter
Copyright (c) 2025 Maxim Sokolenko

This file is part of Blender to Spine2D Mesh Exporter.

Blender to Spine2D Mesh Exporter is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the License,
or (at your option) any later version.

Blender to Spine2D Mesh Exporter is distributed in the hope that it will
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with Blender to Spine2D Mesh Exporter. If not, see <https://www.gnu.org/licenses/>.
This module is dedicated to a single, specific task within the export pipeline: creating a copy of a mesh and marking its edges as seams based on provided segmentation data.

The key functionalities are:
1.  Object Duplication: The `mark_seams_on_copy` function takes an original Blender object and creates a duplicate of it. This ensures that the original object remains untouched while the new copy is prepared for the texturing and UV unwrapping process.
2.  Seam Marking: It iterates through the edges of the new mesh copy using BMesh. It compares each edge's vertex indices against a list of boundary edges (`segmentation_data`) that was generated by the `plane_cut` module. If an edge matches a boundary, it is marked as a "seam".
3.  Data Collection: While marking seams, it also collects detailed information about each seam, including its edge index and the 3D coordinates of its vertices. This data can be used for debugging or more advanced processing if needed.
4.  Flexibility: The function includes a `do_copy` parameter, which allows it to either create a new copy or apply the seams directly to the provided object, offering flexibility for different pipeline stages.

ATTENTION: - This module's primary function is to translate the abstract boundary data from the cutting process into tangible seams on a mesh. The accuracy of the `segmentation_data` input is critical; if this data is incorrect, the seams will be applied in the wrong places, leading to a flawed UV unwrap. The function assumes that the vertex indices in the `segmentation_data` correspond to the vertex indices of the object being processed.
Author: Maxim Sokolenko
"""

import bpy
import bmesh
import logging

logger = logging.getLogger(__name__)

# [CHANGED] The find_boundary_edges_between_segments function has been completely removed.
# It was the source of the problem and is no longer needed.


def mark_seams_on_copy(original_obj, segmentation_data, do_copy=True):
    try:
        if original_obj is None or original_obj.type != "MESH":
            raise TypeError("original_obj must be a MESH type object.")
        if not isinstance(segmentation_data, list):
            raise TypeError("segmentation_data must be a list.")

        logger.debug(
            f"Processing object '{original_obj.name}' for texturing. segmentation_data contains {len(segmentation_data)} elements."
        )

        # If do_copy==True, create a copy, otherwise work with the passed object
        if do_copy:
            new_obj = original_obj.copy()
            new_obj.data = original_obj.data.copy()
            new_obj.name = original_obj.name + "_texturing"
            bpy.context.collection.objects.link(new_obj)
        else:
            new_obj = original_obj
            new_obj.name = original_obj.name + "_texturing"

        bm = bmesh.new()
        bm.from_mesh(new_obj.data)
        bm.verts.ensure_lookup_table()
        bm.edges.ensure_lookup_table()

        seams_info = []
        if not segmentation_data:
            logger.debug("segmentation_data is empty, seams will not be installed.")
        seam_edges_set = set()
        for edge in segmentation_data:
            if isinstance(edge, (list, tuple)) and len(edge) == 2:
                seam_edges_set.add(tuple(sorted(edge)))
            else:
                logger.warning(f"Invalid format of segmentation_data element: {edge}")
        logger.debug(f"Multiple seam edges:{seam_edges_set}")

        for edge in bm.edges:
            v_indices = tuple(sorted([v.index for v in edge.verts]))
            if v_indices in seam_edges_set:
                edge.seam = True
                v_coords = [list(v.co) for v in edge.verts]
                seam_info = {
                    "edge_index": edge.index,
                    "vertex_indices": v_indices,
                    "vertex_coords": v_coords,
                }
                seams_info.append(seam_info)
                logger.debug(
                    f"Edge {v_indices} is labeled as seam. Coordinates: {v_coords}"
                )

        bm.to_mesh(new_obj.data)
        bm.free()
        logger.info(f"Object '{new_obj.name}' processed, {len(seams_info)} seams set.")
        return new_obj, seams_info

    except Exception as e:
        logger.error(f"[ERROR] mark_seams_on_copy: {e}")
        return None, []


def register():
    logger.debug("Registration seam_marker.py")


def unregister():
    logger.debug("Unregistration seam_marker.py")
